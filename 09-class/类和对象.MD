#类和对象
_____________________________________________________________________
###一、类概念及定义
_____________________________________________________________________
####1、相关概念
* （1）类名最好用驼峰命名法
* （2）类名不能与数字开头
* （3）类名不区分大小写
* （4）成员属性可以有值，也可以没有值
* （5）类可以产生N个对象
* （6）类几乎不占用内存，但每个对象都要占用内存
* （7）类要产生对象，只有对象才能够干活，在能够明确责任跟义务
* （8）对象什么时候销毁？当然是php脚本执行完毕后自动销毁，也可以自己手动销毁
####2、类得成员属性及成员方法
* （1）须有权限控制符，权限控制符总共有三个（作用:主要用来保护数据安全）
* （1）public（公共权限）：在任何地方都可以访问，主要指类得内部、类外部、子类中都可以访问
* （2）protected（受保护的权限)：只能在本类中、字类中被访问，在类外不能访问
* （3）private（私有权限）：只能在本类中被访问，在类外、之类中都无权访问
####3、成员方法
* （1）实际开发中建议一个方法只做一件事
* （2）成员方法，一定是哪个对象的方法，不能单独存在
* （3）成员方法要加权限控制符，普通函数不需要加
* （4）成员方法可以省略权限控制符，默认public，建议不要省略
####4、类常量
* （1）类中定义的常量（以对象无关）就叫类常量
* （2）值永远不变，也不能删除，所谓不能修改，是指在一次http请求中不能修改,
 也即是一个脚本开始执行后定义的常量直到脚本运行结束的过程中是不能改的
* （3）在类中定义常量是用const，define定义的是当权脚本中的全局常量
* （4）类常量是类的常量，与对象无关，类常量，只能通过类名来调用，类的成员的属性，只能通过对象
 来调用，成员由具备了私有，公有，保护三个属性
* （5）类名调用类常量：（类名::常量）::叫做范围解析符，对象的东西使用->来访问调用的
* （6）类常量在内存中只能存在一份，因为一个类在内存中只有一份，不会随着对象的增加而增加，所所以类常量
可以被所有的对象共享，使用其的好处就是大大节省内存
* （7）常量的语法说明：没有权限，在哪里都可以访问，const定义的一般是局部常量，常量名不加$符号，尽量大写
 常量的值只能是一个固定的值，不能是一个变量
####5、静态属性与静态方法（static）
* （1）被static修饰的属性就是静态属性，修饰的方法就是静态方法
* （2）静态属性静态方法是属于类的属性与方法，与对象无关，与类相关，因此静态属性跟静态方法也只有一份
* （3）静态属性静态方法的访问方式：类名::静态属性名或静态方法名，目的也是节省内存
* （4）其跟类常量一样，可以被所有对象共享，但是其值是可以被改变的
* （5）对象也可能访问静态属性和静态方法的，如：$p1::$name;//对象访问静态属性。$p1->tell();//对象可以访问静态方法
####6、如何区分静态属性跟类常量
* （1）类常量在脚本周期类永远不会变，但是静态属性是可以变
* （2）静态属性和静态方法是有权限控制的，而类常量没有,
* （3）修饰静态属性和静态方法以及权限的关键字可以不在乎顺序
####7、$this及self关键字
* （1）self关键字，代表当前类,当然只能在类中使用，类外肯定会要用类名
* （2）$this代表当前对象，调用成员属性，成员方法（对象的东西）
* （3）self代表当前类，调用类的常量，静态属性，静态方法（类的东西）
* （4）$this用->来调用成员属性及成员方法，Self用::调用类的常量，静态属性及静态方法
* （5）$this只能用在成员方法中，self可以用在成员方法及静态方法中
* （6）$this只能在成员方法中存在（在类中），其他地方都不能使用
* （7）当使用对象调用类的方法时，会自动将当前对象传递到类的方法中
* （8）在成员方法中，使用$this来代替传递过来的对象
####8、类在内存的中的分布
* （1）对象跟变量一样，存放在栈区
* （2）类得成员属性在堆区，所以打印对象可以打印出来
* （3）类得静态属性跟类常量在静态区，跟对象无关，不能被对象打印
* （4）成员方法在代码区，而对象在栈区，因此打印对象也是看不见成员方法
* （5）打印对象时，只显示成员属性，其他内容都不显示
* （6）栈内存：主要存储标量数据类型跟数组
####9、php的八大数据类型
* （1）标量数据类型：字符串型、整形、浮点型、布尔型
* （2）复合数据类型：数组、对象
* （3）特殊数据类型：资源、NULL
####10、值传递
* （1）字符串型、整形、浮点型、布尔型、数组默认是“值传递”
* （2）对象、资源默认是“引用传递”
* （3）值传递的定义：将一个变量的值，复制一份，传递给另外一个变量，两个变量之间没有任何关系，
修改其中任意一个变量的值，另一个变量都不会改变
* （4）值传递在内存中的表现：标量数据类型变量，其变量名及变量值，都是存储在栈区（栈内存）中，栈内存
速度比较快，但是不能存储太多的东西
####11、引用传递
* （1）将一个变量的“数据地址”，复制一份，传递给另一个变量，两个变量指向了“同一个数据”，
修改其中一个变量的数据，另一个变量也会一起变
* （2）PHP中默认的“引用传递”的数据类型是：对象和资源
* （3）在PHP中，使用&符号可以把标量数据类型和数组，变成“引用传递地址”
_____________________________________________________________________
###二、类的三（四）大特征：封装性、继承性、多态性、抽象性
_____________________________________________________________________
####1、类的封装性
* （1）类得封装性，将敏感数据保护起来，不被外界访问
* （2）类得封装性再次理解：将一个功能的方方面面，封装成一个类，
例如：数据库工具类，把敏感数据操作的所有反面全面封装到类中，
因此，在该类外，不能再使用“mysqli_*”开头的函数
* （3）类得封装性实现，就是通过权限控制符来实现
* （4）在项目中和，所有的成员是属性，一般都是private、protected权限
####2、类得继承
* （1）好处：相同的代码只需要修改一次就够了
* （2）继承的概念：如果一个B类拥有了A类的所有特征信息
* （全部继承，一个不剩，除了private权限外的所有成员属性和方法），则我们就认为B类继承了A类，
* 继承还可以理解成引用传递
* （3）A类（别名）：父类、上层类、基础类（最顶层的类，不会再有了）
* （4）B类（别名）：字类、下层类、派生类
* （5）为什么需要继承？继承是为了实现功能的升级和扩展。如果一个项目不需要升级和扩展，则不用继承
* （6）功能的升级：原来有的功能，对现在的功能进行更加完善的处理
* （7）功能的扩展：原来没有的功能，增加一个新的功能
* （8）重点：~~如果项目需要升级和扩展，不能直接修改原类（一动原来的代码，问题就大了）
，需要创建一个字类，并继承父类，这样才没有问题，所以需要继承~~
* （9）构造方法和析构方法的继承：完全被继承
####3、继承的语法格式
* （1）class Computer extends Commodity
* （2）Computer代表要创建的子类名称
* （3）extends是继承的额关键字，不区分大小写
* （4）Commodity代表已经存在的父类或上层类
####4、单继承和多继承
* （1）单继承：只能从一个父类来继承功能，例如：PHP、JAVA等主流的程序语言都是单继承
* （2）多继承：可以同时从多个父类继承功能，例如：C++
####5、parent关键字
* （1）self代表当前类。parent代表父类
* （2）self可以用来调用本类的内容：类常量、静态属性、静态方法、成员方法
* （3）parent可以用来调用父类的内容：类常量、静态属性、静态方法、成员方法、构造方法
####6、类的多态
* （1）类的多态，就是类的多种形态
* （2）类的多态，主要是指方法重载和方法重写
* （3）函数重载：在一个脚本文件中，定义两个同名函数：PHP不支持
* （4）方法重载：在同一个类中，定义两个同名方法：PHP不支持
* （5）方法重写：父类有一个方法，在子类以同样的名称再定义一次：PHP支持
* （6）功能升级：父类有的功能，子类的功能比它更完善、更详细，通过方法重写实现（方法重写的应用或功能）
如果不需要完善和升级，就不用重写
* （7）方法重写时，子类中不能出现$this
* （8）重写的前提：必须先继承，再重写
####7、方法重写的要求
* （1）子类中重写的方法名称，要与父类方法名称一致；
* （2）子类中重写的方法的参数个数，必须要与父类方法的参数个数一致
* （3）子类中重写的方法的类型，必须要与父类方法的类型一致；父类是成员方法，子类必须是成员方法；
父类是静态方法，子类也必须是静态方法
* （4）子类中重写的方法权限，不能低于父类方法的权限：如果父类方法权限为public，则重写方法必须是public，因为public已经是最高级别；
如果父类方法权限为protected，则重写方法必须是public或者protected；如果父类方法为private，则子类方法无法继承，无法重写
####8、构造方法的重写
*  （1）子类中重写的方法名称，要与父类方法名称一致；(肯定满足，构造方法的名称都是一样的）
*  （2）子类中重写的方法权限，不能低于父类方法的权限：如果父类方法权限为public，则重写方法必须是public，因为public已经是最高级别；
如果父类方法权限为protected，则重写方法必须是public或者protected；如果父类方法为private，则子类方法无法继承，无法重写
*  （3）所有的方法都可以重写，但是，唯独构造方法的重写，没有参数个数必须跟父类一致的要求，也就是参数个数可以不对等
####9、最终类和最终方法
* （1）Final关键字修饰的类就是最终类
* （2）Final关键字修饰的方法就是最终方法
* （3）最终类：该类不能被继承，直接实例化即可，该类已经十分完善，不需要升级和扩展
* （4）最终方法：该方法不能被重写，直接调用即可，该方法已经十分完善，不需要升级了
* （5）那些类可以定义为最终类：数据库操作类
* （6）最终类和最终方法不能同时使用，因为最终类不能被继承，里面的方法自然不能被从重写
####10、抽象类和抽象方法（跟最终类和最终方法相似）
* （1）Abstract关键字修饰的类，就是抽象类
* （2）Abstract关键字修饰的方法，就是抽象方法
* （3）抽象类：该类只能被继承，不能直接实例化。常用于“基础类”
* （4）抽象方法：该方法没有方法体（即没有{}的方法），抽象方法必须先继承，后重写
* （5）如果一个类中有抽象方法，该类必须声明为抽象类，即抽象类和抽象方法是同时出现的
* （6）抽象方法：方法的命名规范，时一种监督机制，且必须被重写（可应用于项目的多人合作和员工进度监督，
如技术经理定义好抽象类和抽象方法，每个抽象方法都必须要实现，否则报错，还有因为方法命名都是
写好的，员工就不会乱取方法名，导致项目维护不方便）
* （7）抽象类中，也可以有其它元素：成员属性、成员方法、静态属性、静态方法、类常量（也可以不写）
* （8）【抽象方法】不能是静态方法，必须是成员方法
* （9）抽象方法可以有参数，也可以没有，自己定
_____________________________________________________________________
###三、构造方法和析构方法
_____________________________________________________________________
####1、构造方法（函数）
* （1）当使用new 关键字，创建一个类的对象时，第一个自动调用的方法，
 就是构造方法，也即是构造函数
* （2）构造方法的名称是固定的：__construct()(js的没有下划线）
* （3）构造方法可以有参数，也可以没有参数
* （4）当new一个类时，类名后跟的小括号里面的参数，就是传给此类的构造函方法的。例如：new Student('张三','34')
* （5）构造方法的作用：对象初始化，例如：给私有属性赋值，数据库对象初始化（连通，选择数据库等）
* （6）一个类，只能有一个构造方法，当然构造方法可有可无
* （7）构造方法必须是成员方法，因此其也是有权限的
* （8）构造方法没有返回值，因为他是初始化对象用的
* （9）构造函数的语法格式：权限控制符 function __construct(形参1，形参2.....) { 对象初始化代码 }
* （10）重点提示：
  > A：在实际项目开发中，成员属性一般都是private、protected权限，很少有public  
  > B：在项目中，成员属性一定没有值  
  > C：在类中没有正在的数据，所有数据都是来自于外部，因为类就仅仅是一个工厂
####2、析构方法
* （1）当销毁一个对象前，自动调用的方法，就是析构方法
* （2）析构方法的名称也是固定的：__destruct()
* （3）析构方法一定没有参数，析构方法一定是成员方法（既然是成员方法，就一定有权限控制符）
* （4）析构方法的作用：主要用于垃圾回收。也有一些实际运用：开可以断开数据库连接、在线人数等
* （5）析构方法一定是公有的，因为对象即将销毁就要自动调用，如果是私有，就没法调用了
* （6）语法结构：权限控制符 function __destruct(){  垃圾回收代码以及其他功能代码 }
